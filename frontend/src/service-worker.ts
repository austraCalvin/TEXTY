/// <reference lib="webworker" />
/* eslint-disable no-restricted-globals */

// This service worker can be customized!
// See https://developers.google.com/web/tools/workbox/modules
// for the list of available Workbox modules, or add any other
// code you'd like.
// You can also remove this file if you'd prefer not to use a
// service worker, and the Workbox build step will be skipped.

import { clientsClaim } from 'workbox-core';
import { ExpirationPlugin } from 'workbox-expiration';
import { precacheAndRoute, createHandlerBoundToURL } from 'workbox-precaching';
import { registerRoute } from 'workbox-routing';
import { StaleWhileRevalidate } from 'workbox-strategies';

declare const self: ServiceWorkerGlobalScope;

clientsClaim();

// Precache all of the assets generated by your build process.
// Their URLs are injected into the manifest variable below.
// This variable must be present somewhere in your service worker file,
// even if you decide not to use precaching. See https://cra.link/PWA
precacheAndRoute(self.__WB_MANIFEST);

// Set up App Shell-style routing, so that all navigation requests
// are fulfilled with your index.html shell. Learn more at
// https://developers.google.com/web/fundamentals/architecture/app-shell
const fileExtensionRegexp = new RegExp('/[^/?]+\\.[^/]+$');
registerRoute(
  // Return false to exempt requests from being fulfilled by index.html.
  ({ request, url }: { request: Request; url: URL }) => {

    console.log("registerRoute_1 --->");
    console.log("request.url:", request.url);
    console.log("url.pathname:", url.pathname);
    console.log("registerRoute_1 --->");

    // If this isn't a navigation, skip.
    if (request.mode !== 'navigate') {
      return false;
    }

    // If this is a URL that starts with /_, skip.
    if (url.pathname.startsWith('/_')) {
      return false;
    }

    // If this looks like a URL for a resource, because it contains
    // a file extension, skip.
    if (url.pathname.match(fileExtensionRegexp)) {
      return false;
    }

    // Return true to signal that we want to use the handler.
    return true;
  },
  createHandlerBoundToURL(process.env.PUBLIC_URL + '/index.html')
);

// An example runtime caching route for requests that aren't handled by the
// precache, in this case same-origin .png requests like those from in public/
registerRoute(
  // Add in any other file extensions or routing criteria as needed.
  ({ url }) => {

    console.log("registerRoute_2 --->");
    console.log("url.origin:", url.origin);
    console.log("self.location.origin:", self.location.origin);
    console.log("url.pathname:", url.pathname);
    console.log("registerRoute_2 --->");

    return url.origin === self.location.origin && url.pathname.endsWith('.png');

  },
  // Customize this strategy as needed, e.g., by changing to CacheFirst.
  new StaleWhileRevalidate({
    cacheName: 'images',
    plugins: [
      // Ensure that once this runtime cache reaches a maximum size the
      // least-recently used images are removed.
      new ExpirationPlugin({ maxEntries: 50 }),
    ],
  })
);

export interface ISendNotificationPush {
  chat: {
    "id": string;
    "name": string;
  };
  message: {
    "user_name"?: string;
    "body": string;
  };
};


// This allows the web app to trigger skipWaiting via
// registration.waiting.postMessage({type: 'SKIP_WAITING'})
type INotificationEvent = NotificationEvent & { "reply"?: any };
self.addEventListener('notificationclick', (e: INotificationEvent) => {

  console.log("notificationclick -");
  const notification_ = e.notification,
    action = e.action,
    reply = e.reply as (string | null);

  notification_.close();

  const chatId = notification_.tag;

  // console.log("data:", data);
  console.log("action:", action);
  console.log("tag:", notification_.tag);
  console.log("body:", notification_.body);
  // console.log("reply:", reply ? reply : "null");

  const currentURL = (`http://localhost:3000/chat/${chatId}`);

  const currentWindowClient = self.clients.matchAll({ "type": "window" }).then((windowClients) => {

    if (windowClients.length) {

      console.log("Client is going to navigate");
      return windowClients[0].navigate(currentURL);

    } else {

      console.log("Browser is going to open a new window");
      return self.clients.openWindow(currentURL);

    };


  });

  e.waitUntil(currentWindowClient);

  // if (reply === null) {

  //   self.clients.openWindow(currentURL);

  // } else {

  //   const convertedReply = reply.split("").map((char) => {

  //     switch (char) {

  //       case " ":
  //         return "%20";
  //       case "/":
  //         return "%2F";
  //       case "\\":
  //         return "%5C";
  //       case ",":
  //         return "%2C";
  //       case "%":
  //         return "%25";
  //       default:
  //         return char;

  //     };

  //   });

  //   self.clients.openWindow(currentURL.concat(`/message/${data.messageId}/reply/?text=${convertedReply}`));

  // };

});

self.addEventListener('message', (event) => {
  if (event.data && event.data.type === 'SKIP_WAITING') {
    self.skipWaiting();
  };
});

// Any other custom service worker logic can go here.
self.addEventListener("push", (e) => {

  if (!e.data) {

    return;

  };

  console.log("public url:", process.env.PUBLIC_URL);

  const currentData = e.data.json() as ISendNotificationPush;
  const { chat, message } = currentData;

  // self.registration.showNotification(currentData.sender, ({ "body": currentData.body, "actions": [{ "action": "reply", "type": "text", "title": "Reply", "placeholder": "Text in here" }] } as unknown) as NotificationOptions);

  const messageBody = decodeURIComponent(message.body.replace(/\+/g,  " "));
  const bodySplit = messageBody.split("");
  bodySplit.length = 20;

  self.registration.showNotification(chat.name, { "tag": chat.id, "body": `${message.user_name ? `${message.user_name}: ` : ""}${bodySplit.join("")}` });

});

//current = { id = @mathew, draft = message } - currentData - if null ->
//@mathew - does not exist in catalog - request
//response = {online, lastOnline}
//once initial data has been recovered
//draft -> post -> creates contact - adds the draft into the object